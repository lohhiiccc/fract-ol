typedef struct s_data
{
    // Autres membres...
    double target_zoom_factor;
    t_complex target_zoom_center;
} t_data;



Main
vars.img.target_zoom_factor = 1.0;
vars.img.target_zoom_center = (t_complex){0.0, 0.0};



void draw_fractal(t_data *img, t_complex min, t_complex max,
    int max_iterations, int (*f)(t_complex, int))
{
    // ...
    while (pixel.x < W_W)
    {
        pixel.y = 0;
        while (pixel.y < W_H)
        {
            // ...
            c.real = (c.real - img->target_zoom_center.real) * img->target_zoom_factor + img->target_zoom_center.real;
            c.imag = (c.imag - img->target_zoom_center.imag) * img->target_zoom_factor + img->target_zoom_center.imag;

            pixel.iterations = f(c, max_iterations);
            // ...
        }
        // ...
    }
    // ...
}

int mouse_hook(int button, int x, int y, t_data *img)
{
    if (button == 4 || button == 5) // Défilement vers le haut ou vers le bas
    {
        double factor = (button == 4) ? 1.1 : 0.9;
        img->target_zoom_factor *= factor;

        // Mettez à jour le centre de zoom cible en fonction de la position de la souris
        img->target_zoom_center.real += (x - W_W / 2) / (W_W / 4) / img->target_zoom_factor;
        img->target_zoom_center.imag += (y - W_H / 2) / (W_H / 4) / img->target_zoom_factor;
    }
    return (0);
}

void update_zoom(t_data *img)
{
    double lerp_factor = 0.1; // Ajustez le facteur de lerp pour la vitesse souhaitée

    // Interpolation linéaire
    img->zoom_factor = img->zoom_factor + (img->target_zoom_factor - img->zoom_factor) * lerp_factor;
    img->zoom_center.real = img->zoom_center.real + (img->target_zoom_center.real - img->zoom_center.real) * lerp_factor;
    img->zoom_center.imag = img->zoom_center.imag + (img->target_zoom_center.imag - img->zoom_center.imag) * lerp_factor;
}

mlx_clear_window(vars.mlx, vars.win);
update_zoom(&vars.img);
draw_fractal(&vars.img, ...);
mlx_put_image_to_window(vars.mlx, vars.win, vars.img.img, 0, 0);





